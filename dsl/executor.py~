from dataclasses import dataclass
from typing import Dict, Any, Tuple, Optional
import torch
from .program import Program
from .ops import OPS_REGISTRY

@dataclass
class TraceStats:
    loss_per_pair: torch.Tensor   # [B]
    iou_per_pair: torch.Tensor    # [B]
    diff_masks: torch.Tensor      # [B, H, W] bool
    color_confusions: torch.Tensor # [B, C, C] counts

class Executor:
    """
    Torch executor over integer grids. Pure, batchable ops.
    State holds a persistent binary selection mask if set by 'select'.
    Inputs:
      x: [B, H, W] ints in [0..C-1]
      y_true: optional for diagnostics
    """
    def __init__(self, num_colors: int = 10, background_color: int = 0):
        self.C = num_colors
        self.bg = background_color

    # ---------- helpers ----------
    def _zeros_like(self, y): return torch.full_like(y, fill_value=self.bg)
    def _clamp_box(self, W, H, x0, y0, w, h):
        x1 = max(0, min(W, x0 + w)); y1 = max(0, min(H, y0 + h))
        x0 = max(0, min(W, x0));     y0 = max(0, min(H, y0))
        return x0, y0, x1, y1

    def _apply_persistent_or_crit_mask(self, y, state_mask: Optional[torch.Tensor], crit: str, val: int):
        """
        Returns a [B,H,W] bool mask according to either persistent selection or one-shot criterion.
        """
        if state_mask is not None:
            return state_mask
        if crit == "color_eq":
            return (y == int(val))
        # "none" or unknown
        return torch.ones_like(y, dtype=torch.bool, device=y.device)

    # ---------- main ----------
    def run(self, program: Program, x: torch.Tensor, y_true: Optional[torch.Tensor] = None,
            return_trace: bool = True) -> Tuple[torch.Tensor, Optional[TraceStats]]:

        y = x.clone()
        device = y.device
        B, H, W = y.shape
        state_mask: Optional[torch.Tensor] = None  # [B,H,W] bool

        for step in program.steps:
            op = step.op_name
            args: Dict[str, Any] = step.args
            spec = OPS_REGISTRY[op]

            if op == "color_map":
                src = int(args["src"]); dst = int(args["dst"])
                y = torch.where(y == src, torch.as_tensor(dst, device=device, dtype=y.dtype), y)

            elif op == "reflect":
                axis = args["axis"]
                y = torch.flip(y, dims=[2] if axis == "V" else [1])

            elif op == "rotate":
                k = int(args["k"]) % 4
                for _ in range(k):
                    y = y.transpose(-1, -2).flip(-1)

            elif op == "translate":
                dx, dy = int(args["dx"]), int(args["dy"])
                mode = args.get("mode", "clip")
                if mode == "wrap":
                    y = torch.roll(y, shifts=(dy, dx), dims=(1, 2))
                else:
                    out = self._zeros_like(y)
                    src_y0 = max(0, -dy); src_y1 = min(H, H - dy if dy >= 0 else H)
                    src_x0 = max(0, -dx); src_x1 = min(W, W - dx if dx >= 0 else W)
                    dst_y0 = max(0,  dy); dst_y1 = dst_y0 + (src_y1 - src_y0)
                    dst_x0 = max(0,  dx); dst_x1 = dst_x0 + (src_x1 - src_x0)
                    if dst_y1 > dst_y0 and dst_x1 > dst_x0:
                        out[:, dst_y0:dst_y1, dst_x0:dst_x1] = y[:, src_y0:src_y1, src_x0:src_x1]
                    y = out

            elif op == "copy":
                sx, sy = int(args["src_x"]), int(args["src_y"])
                w, h    = int(args["w"]), int(args["h"])
                dx, dy = int(args["dst_x"]), int(args["dst_y"])
                sx0, sy0, sx1, sy1 = self._clamp_box(W, H, sx, sy, w, h)
                bw, bh = sx1 - sx0, sy1 - sy0
                if bw > 0 and bh > 0:
                    dx0, dy0, dx1, dy1 = self._clamp_box(W, H, dx, dy, bw, bh)
                    bw2, bh2 = dx1 - dx0, dy1 - dy0
                    bw3, bh3 = min(bw, bw2), min(bh, bh2)
                    if bw3 > 0 and bh3 > 0:
                        y[:, dy0:dy0+bh3, dx0:dx0+bw3] = y[:, sy0:sy0+bh3, sx0:sx0+bw3]

            elif op == "select":
                crit = args.get("crit", "none")
                if crit == "color":
                    val = int(args.get("val", 0))
                    state_mask = (y == val)
                else:
                    state_mask = None  # clear selection

            elif op == "paint":
                color = int(args["color"])
                crit = args.get("crit", "none")
                val = int(args.get("val", 0))
                mask = self._apply_persistent_or_crit_mask(y, state_mask, crit, val)
                y = torch.where(mask, torch.as_tensor(color, device=device, dtype=y.dtype), y)

            elif op == "erase":
                crit = args.get("crit", "none")
                val = int(args.get("val", 0))
                mask = self._apply_persistent_or_crit_mask(y, state_mask, crit, val)
                y = torch.where(mask, torch.as_tensor(self.bg, device=device, dtype=y.dtype), y)

            elif op == "flood_fill":
                # Simplified: replace ALL pixels of seed_color. (A true seeded fill can be added later.)
                seed_color = int(args["seed_color"])
                new_color  = int(args["color"])
                y = torch.where(y == seed_color, torch.as_tensor(new_color, device=device, dtype=y.dtype), y)

            elif op == "repeat":
                axis = args["axis"]; k = int(args["k"]); gap = int(args.get("gap", 0))
                if k <= 1:
                    continue
                if axis == "x":
                    base = y.clone()
                    for _ in range(k - 1):
                        if gap > 0:
                            pad = torch.full((B, H, min(gap, W)), self.bg, dtype=y.dtype, device=device)
                            y = torch.cat([y, pad, base], dim=2)
                        else:
                            y = torch.cat([y, base], dim=2)
                    y = y[:, :, :W]
                else:
                    base = y.clone()
                    for _ in range(k - 1):
                        if gap > 0:
                            pad = torch.full((B, min(gap, H), W), self.bg, dtype=y.dtype, device=device)
                            y = torch.cat([y, pad, base], dim=1)
                        else:
                            y = torch.cat([y, base], dim=1)
                    y = y[:, :H, :]

            else:
                # Unknown op -> no-op
                pass

        trace = None
        if return_trace and y_true is not None:
            diff = (y != y_true)
            loss = diff.float().mean(dim=[1,2])               # Hamming loss per pair
            iou  = 1.0 - loss
            C = self.C
            # color confusion matrix per batch
            conf = torch.zeros(B, C, C, device=device)
            # vectorized counts (loop over colors for clarity; cost ok for C<=10)
            for c_true in range(C):
                m_true = (y_true == c_true)
                for c_pred in range(C):
                    conf[:, c_true, c_pred] = (m_true & (y == c_pred)).sum(dim=[1,2])
            trace = TraceStats(loss_per_pair=loss, iou_per_pair=iou, diff_masks=diff, color_confusions=conf)

        return y, trace
